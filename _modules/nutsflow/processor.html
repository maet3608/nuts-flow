

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nutsflow.processor &mdash; nutsflow 1.0.26 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="nutsflow 1.0.26 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> nutsflow
          

          
          </a>

          
            
            
              <div class="version">
                1.0.26
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/introduction.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nutsflow.html">nutsflow package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">nutsflow</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>nutsflow.processor</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nutsflow.processor</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: processor</span>
<span class="sd">   :synopsis: Nuts that process iterables and return iterables.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">osp</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">itt</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rnd</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="k">as</span> <span class="nn">cl</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isfunction</span><span class="p">,</span> <span class="n">ismethod</span><span class="p">,</span> <span class="n">isbuiltin</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">cPickle</span> <span class="k">as</span> <span class="n">pickle</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">filterfalse</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">iterfunction</span> <span class="k">as</span> <span class="n">itf</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">Nut</span><span class="p">,</span> <span class="n">NutFunction</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="k">import</span> <span class="n">as_tuple</span><span class="p">,</span> <span class="n">as_list</span><span class="p">,</span> <span class="n">as_set</span><span class="p">,</span> <span class="n">console</span><span class="p">,</span> <span class="n">timestr</span><span class="p">,</span> <span class="n">is_iterable</span>
<span class="kn">from</span> <span class="nn">.factory</span> <span class="k">import</span> <span class="n">nut_processor</span>
<span class="kn">from</span> <span class="nn">.function</span> <span class="k">import</span> <span class="n">Identity</span>
<span class="kn">from</span> <span class="nn">.sink</span> <span class="k">import</span> <span class="n">Consume</span><span class="p">,</span> <span class="n">Collect</span><span class="p">,</span> <span class="n">Head</span>


<div class="viewcode-block" id="Take"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Take">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Take</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Take(n)</span>

<span class="sd">    Return first n elements of iterable</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Take(2) &gt;&gt; Collect()</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int n: Number of elements to take</span>
<span class="sd">    :return: First n elements of iterable</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itf</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="Slice"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Slice">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Slice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Slice([start,] stop[, stride])</span>

<span class="sd">    Return slice of elements from iterable.</span>
<span class="sd">    See https://docs.python.org/2/library/itertools.html#itertools.islice</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect</span>
<span class="sd">     </span>
<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Slice(2) &gt;&gt; Collect()</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Slice(1, 3) &gt;&gt; Collect()</span>
<span class="sd">    [2, 3]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Slice(0, 4, 2) &gt;&gt; Collect()</span>
<span class="sd">    [1, 3]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int start: Start index of slice.</span>
<span class="sd">    :param int stop: End index of slice.</span>
<span class="sd">    :param int step: Step size of slice.</span>
<span class="sd">    :return: Elements sliced from iterable</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Window"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Window">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Window</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Window(n)</span>

<span class="sd">    Sliding window of size n over elements in iterable.</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Window() &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2), (2, 3), (3, 4)]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Window(3) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, 3), (2, 3, 4)]</span>

<span class="sd">    &gt;&gt;&gt; &#39;test&#39; &gt;&gt; Window(2) &gt;&gt; Map(&#39;&#39;.join) &gt;&gt; Collect()</span>
<span class="sd">    [&#39;te&#39;, &#39;es&#39;, &#39;st&#39;]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int n: Size of window</span>
<span class="sd">    :return: iterator with tuples of length n</span>
<span class="sd">    :rtype: iterator over tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">it</span> <span class="o">&gt;&gt;</span> <span class="n">Take</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">win</span><span class="p">)</span></div>


<div class="viewcode-block" id="Concat"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Concat">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Concat</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Concat(*iterables)</span>

<span class="sd">    Concatenate iterables.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Range, Collect</span>

<span class="sd">    &gt;&gt;&gt; Range(5) &gt;&gt; Concat(&#39;abc&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [0, 1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    &gt;&gt;&gt; &#39;12&#39; &gt;&gt; Concat(&#39;abcd&#39;, &#39;+-&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [&#39;1&#39;, &#39;2&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;+&#39;, &#39;-&#39;]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param iterable iterables: Iterables to concatenate</span>
<span class="sd">    :return: Concatenated iterators</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itt</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Interleave">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Interleave</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Interleave(*iterables)</span>

<span class="sd">    Interleave elements of iterable with elements of given iterables.</span>
<span class="sd">    Similar to iterable &gt;&gt; Zip(*iterables) &gt;&gt; Flatten() but longest iterable</span>
<span class="sd">    determines length of interleaved iterator.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Range, Collect</span>
<span class="sd">    &gt;&gt;&gt; Range(5) &gt;&gt; Interleave(&#39;abc&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [0, &#39;a&#39;, 1, &#39;b&#39;, 2, &#39;c&#39;, 3, 4]</span>

<span class="sd">    &gt;&gt;&gt; &#39;12&#39; &gt;&gt; Interleave(&#39;abcd&#39;, &#39;+-&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [&#39;1&#39;, &#39;a&#39;, &#39;+&#39;, &#39;2&#39;, &#39;b&#39;, &#39;-&#39;, &#39;c&#39;, &#39;d&#39;]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param iterable iterables: Iterables to interleave</span>
<span class="sd">    :return: Iterator over interleaved elements.</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itf</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">)</span></div>


<div class="viewcode-block" id="Zip"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Zip">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Zip</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">iterable2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Zip(*iterables)</span>

<span class="sd">    Zip elements of iterable with elements of given iterables.</span>
<span class="sd">    Zip finishes when shortest iterable is exhausted.</span>
<span class="sd">    See https://docs.python.org/2/library/itertools.html#itertools.izip</span>
<span class="sd">    And https://docs.python.org/2/library/itertools.html#itertools.izip_longest</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect</span>

<span class="sd">    &gt;&gt;&gt; [0, 1, 2] &gt;&gt; Zip(&#39;abc&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)]</span>

<span class="sd">    &gt;&gt;&gt; &#39;12&#39; &gt;&gt; Zip(&#39;abcd&#39;, &#39;+-&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [(&#39;1&#39;, &#39;a&#39;, &#39;+&#39;), (&#39;2&#39;, &#39;b&#39;, &#39;-&#39;)]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param iterable iterables: Iterables to zip</span>
<span class="sd">    :return: Zipped elements from iterables.</span>
<span class="sd">    :rtype: iterator over tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">iterable2</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">)</span></div>


<div class="viewcode-block" id="ZipWith"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.ZipWith">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">ZipWith</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; ZipWith(f, *iterables)</span>

<span class="sd">    Zips the given iterables, unpacks them and applies the given function.</span>

<span class="sd">    &gt;&gt;&gt; add = lambda a, b: a + b</span>
<span class="sd">    &gt;&gt;&gt; [1, 2, 3] &gt;&gt; ZipWith(add, [2, 3, 4]) &gt;&gt; Collect()</span>
<span class="sd">    [3, 5, 7]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param iterable iterables: Any iterables</span>
<span class="sd">    :param function f: Function to apply to zipped input iterables</span>
<span class="sd">    :return: iterator of result of f() applied to zipped iterables</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iterables</span> <span class="o">=</span> <span class="p">[</span><span class="n">iterable</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterables</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itt</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">))</span></div>


<div class="viewcode-block" id="Append"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Append">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Append</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Append(items)</span>

<span class="sd">    Append item(s) to lists/tuples in iterable.</span>

<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Append(&#39;X&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, &#39;X&#39;), (3, 4, &#39;X&#39;)]</span>

<span class="sd">    &gt;&gt;&gt; items = [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Append(items) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, &#39;a&#39;), (3, 4, &#39;b&#39;)]</span>

<span class="sd">    &gt;&gt;&gt; items = [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Append(items) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, &#39;a&#39;, &#39;b&#39;), (3, 4, &#39;c&#39;, &#39;d&#39;)]</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Enumerate</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Append(Enumerate()) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, 0), (3, 4, 1)]</span>

<span class="sd">    :param iterable iterable iterable: Any iterable over tuples or lists</span>
<span class="sd">    :param iterable|object items: A single object or an iterable over objects.</span>
<span class="sd">    :return: iterator where items are appended to the iterable elements.</span>
<span class="sd">    :rtype: iterator over tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">items</span> <span class="o">=</span> <span class="n">items</span> <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">else</span> <span class="n">itt</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">+</span> <span class="n">as_tuple</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>


<div class="viewcode-block" id="Insert"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Insert">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Insert</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Insert(index, items)</span>

<span class="sd">    Insert item(s) into lists/tuples in iterable.</span>

<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Insert(1, &#39;X&#39;) &gt;&gt; Collect()</span>
<span class="sd">    [(1, &#39;X&#39;, 2), (3, &#39;X&#39;, 4)]</span>

<span class="sd">    &gt;&gt;&gt; items = [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Insert(2, items) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 2, &#39;a&#39;), (3, 4, &#39;b&#39;)]</span>

<span class="sd">    &gt;&gt;&gt; items = [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Insert(1, items) &gt;&gt; Collect()</span>
<span class="sd">    [(1, &#39;a&#39;, &#39;b&#39;, 2), (3, &#39;c&#39;, &#39;d&#39;, 4)]</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Enumerate</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; Insert(0, Enumerate()) &gt;&gt; Collect()</span>
<span class="sd">    [(0, 1, 2), (1, 3, 4)]</span>

<span class="sd">    :param iterable iterable iterable: Any iterable over tuples or lists</span>
<span class="sd">    :param int index: Index at which position items are inserted.</span>
<span class="sd">    :param iterable|object items: A single object or an iterable over objects.</span>
<span class="sd">    :return: iterator where items are inserted into the iterable elements.</span>
<span class="sd">    :rtype: iterator over tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">items</span> <span class="o">=</span> <span class="n">items</span> <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">else</span> <span class="n">itt</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[:</span><span class="n">index</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="n">index</span><span class="p">:]</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">as_list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span></div>


<span class="n">Dedupe</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itf</span><span class="o">.</span><span class="n">unique</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Dedupe([key])</span>

<span class="sd">Return only unique elements in iterable. Can have very high memory consumption</span>
<span class="sd">if iterable is long and many elements are unique!</span>

<span class="sd">&gt;&gt;&gt; [2,3,1,1,2,4] &gt;&gt; Dedupe() &gt;&gt; Collect()</span>
<span class="sd">[2, 3, 1, 4]</span>

<span class="sd">&gt;&gt;&gt; data = [(1,&#39;a&#39;), (2,&#39;a&#39;), (3,&#39;b&#39;)]</span>
<span class="sd">&gt;&gt;&gt; data &gt;&gt; Dedupe(key=lambda (x,y): y) &gt;&gt; Collect()</span>
<span class="sd">[(1, &#39;a&#39;), (3, &#39;b&#39;)]</span>

<span class="sd">&gt;&gt;&gt; data &gt;&gt; Dedupe(_[1]) &gt;&gt; Collect()</span>
<span class="sd">[(1, &#39;a&#39;), (3, &#39;b&#39;)]</span>

<span class="sd">:param iterable iterable: Any iterable, e.g. list, range, ...</span>
<span class="sd">:param key: Function used to compare for equality.</span>
<span class="sd">:return: Iterator over unique elements.</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Chunk</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itf</span><span class="o">.</span><span class="n">chunked</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Chunk(n)</span>

<span class="sd">Split iterable in chunks of size n, where each chunk is also an iterator.</span>
<span class="sd">see also GroupBySorted(), ChunkWhen(), ChunkBy()</span>

<span class="sd">&gt;&gt;&gt; for chunk in Range(5) &gt;&gt; Chunk(2):</span>
<span class="sd">&gt;&gt;&gt; ... print list(chunk)</span>
<span class="sd">[0, 1]</span>
<span class="sd">[2, 3]</span>
<span class="sd">[4]</span>

<span class="sd">:param iterable iterable: Any iterable, e.g. list, range, ...</span>
<span class="sd">:param int n: Chunk size</span>
<span class="sd">:return: Chunked iterable</span>
<span class="sd">:rtype: Iterator over iterators</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="ChunkWhen"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.ChunkWhen">[docs]</a><span class="k">class</span> <span class="nc">ChunkWhen</span><span class="p">(</span><span class="n">Nut</span><span class="p">):</span>
<div class="viewcode-block" id="ChunkWhen.__init__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.ChunkWhen.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        iterable &gt;&gt; ChunkWhen(func)</span>

<span class="sd">        Chunk iterable and create new chunk every time func returns True.</span>
<span class="sd">        see also GroupBySorted(), Chunk(), ChunkBy()</span>

<span class="sd">        &gt;&gt;&gt; from nutsflow import Map, Join, Collect</span>
<span class="sd">        &gt;&gt;&gt; func = lambda x: x == &#39;|&#39;</span>
<span class="sd">        &gt;&gt;&gt; &#39;0|12|345|6&#39; &gt;&gt; ChunkWhen(func) &gt;&gt; Map(Join()) &gt;&gt; Collect()</span>
<span class="sd">        [&#39;0&#39;, &#39;|12&#39;, &#39;|345&#39;, &#39;|6&#39;]</span>

<span class="sd">        :param function func: Boolean function that indicates chunks.</span>
<span class="sd">            New chunk is created if return value is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span></div>

    <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return keys (= counter) for groups (=chunks)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cnt</span>

<div class="viewcode-block" id="ChunkWhen.__rrshift__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.ChunkWhen.__rrshift__">[docs]</a>    <span class="k">def</span> <span class="nf">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param any iterable iterable: iterable to create chunks for.</span>
<span class="sd">        :return: Iterator over chunks, where each chunk is an iterator itself.</span>
<span class="sd">        :rtype: iterator over iterators</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">iterable</span> <span class="o">&gt;&gt;</span> <span class="n">ChunkBy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ChunkBy"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.ChunkBy">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">ChunkBy</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; ChunkBy(func)</span>

<span class="sd">    Chunk iterable and create chunk every time func changes its return value.</span>
<span class="sd">    see also GroupBySorted(), Chunk(), ChunkWhen()</span>

<span class="sd">    &gt;&gt;&gt; [1,1, 2, 3,3,3] &gt;&gt; ChunkBy(lambda x: x) &gt;&gt; Map(list) &gt;&gt; Collect()</span>
<span class="sd">    [[1, 1], [2], [3, 3, 3]]</span>

<span class="sd">    &gt;&gt;&gt; [1,1, 2, 3,3,3] &gt;&gt; ChunkBy(lambda x: x &lt; 3) &gt;&gt; Map(list) &gt;&gt; Collect()</span>
<span class="sd">    [[1, 1, 2], [3, 3, 3]]</span>

<span class="sd">    :param iterable iterable: Any iterable, e.g. list, range, ...</span>
<span class="sd">    :param function func: Functions the iterable is chunked by </span>
<span class="sd">    :return: Chunked iterable</span>
<span class="sd">    :rtype: Iterator over iterators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groupiter</span> <span class="o">=</span> <span class="n">itt</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">groupiter</span><span class="p">)</span></div>


<span class="n">Cycle</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Cycle()</span>

<span class="sd">Cycle through iterable indefinitely. Large memory consumption if iterable is</span>
<span class="sd">large!</span>

<span class="sd">&gt;&gt;&gt; [1, 2] &gt;&gt; Cycle() &gt;&gt; Take(5) &gt;&gt; Collect()</span>
<span class="sd">[1, 2, 1, 2, 1]</span>

<span class="sd">:param iterable iterable: Any iterable, e.g. list, range, ...</span>
<span class="sd">:return: Cycled input iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Flatten"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Flatten">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Flatten</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Flatten()</span>

<span class="sd">    Flatten the iterables within the iterable and non-iterables are passed</span>
<span class="sd">    through. Only one level is flattened. Chain Flatten to flatten deeper</span>
<span class="sd">    structures.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4, 5), 6] &gt;&gt; Flatten() &gt;&gt; Collect()</span>
<span class="sd">    [1, 2, 3, 4, 5, 6]</span>

<span class="sd">    &gt;&gt;&gt; [(1, (2)), (3, (4, 5)), 6] &gt;&gt; Flatten() &gt;&gt; Flatten() &gt;&gt; Collect()</span>
<span class="sd">    [1, 2, 3, 4, 5, 6]</span>

<span class="sd">    :param iterable iterable: Any iterable.</span>
<span class="sd">    :return: Flattened iterable</span>
<span class="sd">    :rtype: Iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">it</span></div>


<div class="viewcode-block" id="FlattenCol"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.FlattenCol">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">FlattenCol</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; FlattenCol(cols)</span>

<span class="sd">    Flattens the specified columns of the tuples/iterables within the iterable.</span>
<span class="sd">    Only one level is flattened.</span>

<span class="sd">    (1 3)  (5 7)</span>
<span class="sd">    (2 4)  (6 8)   &gt;&gt; FlattenCol((0,1) &gt;&gt;   (1 3)  (2 4)  (5 7)  (6 8)</span>

<span class="sd">    If a column contains a single element (instead of an iterable) it is </span>
<span class="sd">    wrapped into a repeater. This allows to flatten columns that are iterable</span>
<span class="sd">    together with non-iterable columns, e.g.</span>

<span class="sd">    (1 3)  (6 7)</span>
<span class="sd">    (2  )  (  8)   &gt;&gt; FlattenCols((0,1) &gt;&gt;   (1 3)  (2 3)  (6 7)  (6 8)</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect</span>
<span class="sd">    &gt;&gt;&gt; data = [([1, 2], [3, 4]), ([5, 6], [7, 8])]</span>
<span class="sd">    &gt;&gt;&gt; data &gt;&gt; FlattenCol(0) &gt;&gt; Collect()</span>
<span class="sd">    [(1,), (2,), (5,), (6,)]</span>

<span class="sd">    &gt;&gt;&gt; data &gt;&gt; FlattenCol((0, 1)) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 3), (2, 4), (5, 7), (6, 8)]</span>

<span class="sd">    &gt;&gt;&gt; data &gt;&gt; FlattenCol((1, 0)) &gt;&gt; Collect()</span>
<span class="sd">    [(3, 1), (4, 2), (7, 5), (8, 6)]</span>

<span class="sd">    &gt;&gt;&gt; data &gt;&gt; FlattenCol((1, 1, 0)) &gt;&gt; Collect()</span>
<span class="sd">    [(3, 3, 1), (4, 4, 2), (7, 7, 5), (8, 8, 6)]</span>

<span class="sd">    &gt;&gt;&gt; data = [([1, 2], 3), (6, [7, 8])]</span>
<span class="sd">    &gt;&gt;&gt; data &gt;&gt; FlattenCol((0, 1)) &gt;&gt; Collect()</span>
<span class="sd">    [(1, 3), (2, 3), (6, 7), (6, 8)]</span>

<span class="sd">    :param iterable iterable: Any iterable.</span>
<span class="sd">    :params int|tuple columns: Column index or indices</span>
<span class="sd">    :return: Flattened columns of iterable</span>
<span class="sd">    :rtype: generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">as_tuple</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span> <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">else</span> <span class="n">itt</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">get</span><span class="p">(</span><span class="n">es</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="n">e</span></div>


<span class="n">FlatMap</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itf</span><span class="o">.</span><span class="n">flatmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; FlatMap(func)</span>

<span class="sd">Map function on iterable and flatten. Equivalent to</span>
<span class="sd">iterable &gt;&gt; Map(func) &gt;&gt; Flatten()</span>

<span class="sd">&gt;&gt;&gt; [[0], [1], [2]] &gt;&gt; FlatMap(_) &gt;&gt; Collect()</span>
<span class="sd">[0, 1, 2]</span>

<span class="sd">&gt;&gt;&gt; [[0], [1], [2]] &gt;&gt; FlatMap(_ * 2) &gt;&gt; Collect()</span>
<span class="sd">[0, 0, 1, 1, 2, 2]</span>

<span class="sd">:param iterable iterable: Any iterable.</span>
<span class="sd">:param function func: Mapping function.</span>
<span class="sd">:return: Mapped and flattened iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Map</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Map(func, *iterables)</span>

<span class="sd">Map function on iterable.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.imap</span>

<span class="sd">&gt;&gt;&gt; [0, 1, 2] &gt;&gt; Map(_ * 2) &gt;&gt; Collect()</span>
<span class="sd">[0, 2, 4]</span>

<span class="sd">&gt;&gt;&gt; [&#39;ab&#39;, &#39;cde&#39;] &gt;&gt; Map(len) &gt;&gt; Collect()</span>
<span class="sd">[2, 3]</span>

<span class="sd">&gt;&gt; [2, 3, 10] &gt;&gt; Map(pow, [5, 2, 3]) &gt;&gt; Collect()</span>
<span class="sd">[32, 9, 1000]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param iterables iterables: Any iterables.</span>
<span class="sd">:param function func: Mapping function.</span>
<span class="sd">:return: Mapped iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Filter</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Filter(func)</span>

<span class="sd">Filter elements from iterable based on predicate function.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.ifilter</span>

<span class="sd">&gt;&gt;&gt; [0, 1, 2, 3] &gt;&gt; Filter(_ &lt; 2) &gt;&gt; Collect()</span>
<span class="sd">[0, 1]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param function func: Predicate function. Element is removed if False.</span>
<span class="sd">:return: Filtered iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">FilterFalse</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">filterfalse</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; FilterFalse(func)</span>

<span class="sd">Filter elements from iterable based on predicate function.</span>
<span class="sd">Same as Filter but elements are removed (not kept) if predicate function</span>
<span class="sd">returns True.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.ifilterfalse</span>

<span class="sd">&gt;&gt;&gt; [0, 1, 2, 3] &gt;&gt; FilterFalse(_ &gt;= 2) &gt;&gt; Collect()</span>
<span class="sd">[0, 1]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param function func: Predicate function. Element is removed if True.</span>
<span class="sd">:return: Filtered iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Partition</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itf</span><span class="o">.</span><span class="n">partition</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">partition1, partition2 = iterable &gt;&gt; Partition(func)</span>

<span class="sd">Split iterable into two partitions based on predicate function</span>

<span class="sd">&gt;&gt;&gt; smaller, larger = Range(5) &gt;&gt; Partition(_ &lt; 3)</span>
<span class="sd">&gt;&gt;&gt; smaller &gt;&gt; Collect()</span>
<span class="sd">[0, 1, 2]</span>
<span class="sd">&gt;&gt;&gt; larger &gt;&gt; Collect()</span>
<span class="sd">[3, 4]</span>

<span class="sd">:param iterable: Any iterable, e.g. list, range, ...</span>
<span class="sd">:param pred: Predicate function.</span>
<span class="sd">:return: Partition iterators</span>
<span class="sd">:rtype: Two iterators</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">TakeWhile</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">takewhile</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; TakeWhile(func)</span>

<span class="sd">Take elements from iterable while predicte function is True.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.takewhile</span>

<span class="sd">&gt;&gt;&gt; [0, 1, 2, 3, 0] &gt;&gt; TakeWhile(_ &lt; 2) &gt;&gt; Collect()</span>
<span class="sd">[0, 1]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param function func: Predicate function.</span>
<span class="sd">:return: Iterable</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="DropWhile"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.DropWhile">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">DropWhile</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; DropWhile(func)</span>

<span class="sd">    Skip elements in iterable while predicate function is True.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import _</span>
<span class="sd">    &gt;&gt;&gt; [0, 1, 2, 3, 0] &gt;&gt; DropWhile(_ &lt; 2) &gt;&gt; Collect()</span>
<span class="sd">    [2, 3, 0]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param function func: Predicate function.</span>
<span class="sd">    :return: Iterable</span>
<span class="sd">    :rtype: Iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itt</span><span class="o">.</span><span class="n">dropwhile</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span></div>


<span class="n">Permutate</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">permutations</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Permutate([,r])</span>

<span class="sd">Return successive r length permutations of elements in the iterable.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.permutations</span>

<span class="sd">&gt;&gt;&gt; &#39;ABC&#39; &gt;&gt; Permutate(2) &gt;&gt; Collect()</span>
<span class="sd">[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;)]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param int r: Permutation of length r are generated.</span>
<span class="sd">              If r is not specified or is None, then r defaults</span>
<span class="sd">              to the length of the iterable and all possible full-length</span>
<span class="sd">              permutations are generated.</span>
<span class="sd">:return: Iterable over permutations</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Combine</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">combinations</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Combine(r)</span>

<span class="sd">Return r length subsequences of elements from the input iterable.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.combinations</span>

<span class="sd">&gt;&gt;&gt; &#39;ABC&#39; &gt;&gt; Combine(2) &gt;&gt; Collect()</span>
<span class="sd">[(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;)]</span>

<span class="sd">&gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Combine(3) &gt;&gt; Collect()</span>
<span class="sd">[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param int r: Length of combinations</span>
<span class="sd">:return: Iterable over combinations</span>
<span class="sd">:rtype: Iterator</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">Tee</span> <span class="o">=</span> <span class="n">nut_processor</span><span class="p">(</span><span class="n">itt</span><span class="o">.</span><span class="n">tee</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">iterable &gt;&gt; Tee([n=2])</span>

<span class="sd">Return n independent iterators from a single iterable. Can consume large</span>
<span class="sd">amounts of memory if iterable is large and tee&#39;s are not processed in</span>
<span class="sd">parallel.</span>
<span class="sd">See https://docs.python.org/2/library/itertools.html#itertools.tee</span>

<span class="sd">&gt;&gt;&gt; it1, it2  = [1, 2, 3] &gt;&gt; Tee(2)</span>
<span class="sd">&gt;&gt;&gt; it1 &gt;&gt; Collect()</span>
<span class="sd">[1, 2, 3]</span>
<span class="sd">&gt;&gt;&gt; it2 &gt;&gt; Collect()</span>
<span class="sd">[1, 2, 3]</span>

<span class="sd">:param iterable iterable: Any iterable</span>
<span class="sd">:param int n: Number of iterators to return.</span>
<span class="sd">:return: n iterators</span>
<span class="sd">:rtype: (Iterator, ...)</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="If"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.If">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">If</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">if_nut</span><span class="p">,</span> <span class="n">else_nut</span><span class="o">=</span><span class="n">Identity</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; If(cond, if_nut, [,else_nut])</span>

<span class="sd">    Depending on condition cond execute if_nut or else_nut. Useful for</span>
<span class="sd">    conditional flows.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Square, Collect</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3] &gt;&gt; If(True, Square()) &gt;&gt; Collect()</span>
<span class="sd">    [1, 4, 9]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3] &gt;&gt; If(False, Square(), Take(1)) &gt;&gt; Collect()</span>
<span class="sd">    [1]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param bool cond: Boolean conditional value.</span>
<span class="sd">    :param Nut if_nut: Nut to be executed if cond == True</span>
<span class="sd">    :param Nut else_nut: Nut to be executed if cond == False</span>
<span class="sd">    :return: Result of if_nut or else_nut</span>
<span class="sd">    :rtype: Any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iterable</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">if_nut</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="n">else_nut</span><span class="p">)</span></div>


<div class="viewcode-block" id="Drop"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Drop">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Drop</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Drop(n)</span>

<span class="sd">    Drop first n elements in iterable.</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Drop(2) &gt;&gt; Collect()</span>
<span class="sd">    [3, 4]</span>


<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int n: Number of elements to drop</span>
<span class="sd">    :return: Iterator without dropped elements</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">it</span> <span class="o">&gt;&gt;</span> <span class="n">Take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Consume</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">it</span></div>


<div class="viewcode-block" id="Pick"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Pick">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Pick</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">p_n</span><span class="p">,</span> <span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Pick(p_n)</span>

<span class="sd">    Pick every p_n-th element from the iterable if p_n is an integer,</span>
<span class="sd">    otherwise pick randomly with probability p_n.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Range, Collect</span>
<span class="sd">    &gt;&gt;&gt; from nutsflow.common import StableRandom</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Pick(0.0) &gt;&gt; Collect()</span>
<span class="sd">    []</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Pick(1.0) &gt;&gt; Collect()</span>
<span class="sd">    [1, 2, 3, 4]</span>

<span class="sd">    &gt;&gt;&gt; import random as rnd</span>
<span class="sd">    &gt;&gt;&gt; Range(10) &gt;&gt; Pick(0.5, StableRandom(1)) &gt;&gt; Collect()</span>
<span class="sd">    [0, 4, 5, 6, 8, 9]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 3, 4] &gt;&gt; Pick(2) &gt;&gt; Collect()</span>
<span class="sd">    [1, 3]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param float|int p_n: Probability p in [0, 1] or</span>
<span class="sd">        integer n for every n-th element</span>
<span class="sd">    :param Random|None rand: Random number generator. If None, random.Random()</span>
<span class="sd">        is used.</span>
<span class="sd">    :return: Iterator over picked elements.</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rand</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span> <span class="k">if</span> <span class="n">rand</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rand</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;p_n must not be negative &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p_n</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p_n</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p_n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Probability must be in [0, 1]: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p_n</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iterable</span> <span class="k">if</span> <span class="n">rand</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">p_n</span><span class="p">)</span></div>


<div class="viewcode-block" id="GroupBy"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.GroupBy">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">GroupBy</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">keycol</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">nokey</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; GroupBy(keycol=lambda x: x, nokey=False)</span>

<span class="sd">    Group elements of iterable based on a column value of the element or</span>
<span class="sd">    the function value of keycol for the element.</span>
<span class="sd">    Note that elements of iterable do not need to be sorted.</span>
<span class="sd">    GroupBy will store all elements in memory!</span>
<span class="sd">    If the iterable is sorted use GroupBySorted() instead.</span>
<span class="sd">    see also Chunk(), ChunkWhen(), ChunkBy()</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Sort</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 1, 1, 3] &gt;&gt; GroupBy() &gt;&gt; Sort()</span>
<span class="sd">    [(1, [1, 1, 1]), (2, [2]), (3, [3])]</span>

<span class="sd">    &gt;&gt;&gt; [1, 2, 1, 1, 3] &gt;&gt; GroupBy(nokey=True) &gt;&gt; Sort()</span>
<span class="sd">    [[1, 1, 1], [2], [3]]</span>

<span class="sd">    &gt;&gt;&gt; [&#39;--&#39;, &#39;+++&#39;, &#39;**&#39;] &gt;&gt; GroupBy(len) &gt;&gt; Sort()</span>
<span class="sd">    [(2, [&#39;--&#39;, &#39;**&#39;]), (3, [&#39;+++&#39;])]</span>

<span class="sd">    &gt;&gt;&gt; [&#39;a3&#39;, &#39;b2&#39;, &#39;c1&#39;] &gt;&gt; GroupBy(1) &gt;&gt; Sort()</span>
<span class="sd">     [(&#39;1&#39;, [&#39;c1&#39;]), (&#39;2&#39;, [&#39;b2&#39;]), (&#39;3&#39;, [&#39;a3&#39;])]</span>

<span class="sd">    &gt;&gt;&gt; [(1,3), (2,2), (3,1)] &gt;&gt; GroupBy(1, nokey=True) &gt;&gt; Sort()</span>
<span class="sd">    [[(1, 3)], [(2, 2)], [(3, 1)]]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int|function keycol: Column index or key function.</span>
<span class="sd">    :param bool nokey: True: results will not contain keys for groups, only</span>
<span class="sd">        the groups themselves.</span>
<span class="sd">    :return: Iterator over groups.</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">isfunc</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">keycol</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="n">isfunc</span> <span class="k">else</span> <span class="n">e</span><span class="p">[</span><span class="n">keycol</span><span class="p">]</span>
        <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="k">if</span> <span class="n">nokey</span> <span class="k">else</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span></div>


<div class="viewcode-block" id="GroupBySorted"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.GroupBySorted">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">GroupBySorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">keycol</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">nokey</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; GroupBySorted(prob, keycol=lambda x: x, nokey=False)</span>

<span class="sd">    Group elements of iterable based on a column value of the element or</span>
<span class="sd">    the function value of key_or_col for the element.</span>
<span class="sd">    Iterable needs to be sorted according to keycol!</span>
<span class="sd">    See https://docs.python.org/2/library/itertools.html#itertools.groupby</span>
<span class="sd">    If iterable is not sorted use GroupBy but be aware that it stores all</span>
<span class="sd">    elements of the iterable in memory!</span>
<span class="sd">    see also Chunk(), ChunkWhen(), ChunkBy()</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect, nut_sink</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; @nut_sink</span>
<span class="sd">    ... def ViewResult(iterable):</span>
<span class="sd">    ...     return iterable &gt;&gt; Map(lambda t: (t[0], list(t[1]))) &gt;&gt; Collect()</span>

<span class="sd">    &gt;&gt;&gt; [1, 1, 1, 2, 3] &gt;&gt; GroupBySorted() &gt;&gt; ViewResult()</span>
<span class="sd">    [(1, [1, 1, 1]), (2, [2]), (3, [3])]</span>

<span class="sd">    &gt;&gt;&gt; [1, 1, 1, 2, 3] &gt;&gt; GroupBySorted(nokey=True) &gt;&gt; Map(list) &gt;&gt; Collect()</span>
<span class="sd">    [[1, 1, 1], [2], [3]]</span>

<span class="sd">    &gt;&gt;&gt; [&#39;--&#39;, &#39;**&#39;, &#39;+++&#39;] &gt;&gt; GroupBySorted(len) &gt;&gt; ViewResult()</span>
<span class="sd">    [(2, [&#39;--&#39;, &#39;**&#39;]), (3, [&#39;+++&#39;])]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int|function keycol: Column index or key function.</span>
<span class="sd">    :param bool nokey: True: results will not contain keys for groups, only</span>
<span class="sd">        the groups themselves.</span>
<span class="sd">    :return: Iterator over groups where values are iterators.</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">isfunc</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keycol</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">keycol</span> <span class="k">if</span> <span class="n">isfunc</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">keycol</span><span class="p">]</span>
    <span class="n">groupiter</span> <span class="o">=</span> <span class="n">itt</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k_v</span><span class="p">:</span> <span class="n">k_v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">groupiter</span><span class="p">)</span> <span class="k">if</span> <span class="n">nokey</span> <span class="k">else</span> <span class="n">groupiter</span></div>


<div class="viewcode-block" id="Clone"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Clone">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Clone</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Clone(n)</span>

<span class="sd">    Clones elements in the iterable n times.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Range, Collect, Join</span>
<span class="sd">    &gt;&gt;&gt; Range(4) &gt;&gt; Clone(2) &gt;&gt; Collect()</span>
<span class="sd">    [0, 0, 1, 1, 2, 2, 3, 3]</span>

<span class="sd">    &gt;&gt;&gt; &#39;abc&#39; &gt;&gt; Clone(3) &gt;&gt; Join()</span>
<span class="sd">    &#39;aaabbbccc&#39;</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param n: Number of clones</span>
<span class="sd">    :return: Generator over cloned elements in iterable</span>
<span class="sd">    :rtype: generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">e</span></div>


<div class="viewcode-block" id="Shuffle"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Shuffle">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Shuffle</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">buffersize</span><span class="p">,</span> <span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Shuffle(buffersize)</span>

<span class="sd">    Perform (partial) random shuffle of the elements in the iterable.</span>
<span class="sd">    Elements of the iterable are stored in a buffer of the given size</span>
<span class="sd">    and shuffled within. If buffersize is smaller than the length of</span>
<span class="sd">    the iterable the shuffle is therefore partial in the sense that the</span>
<span class="sd">    &#39;window&#39; of the shuffle is limited to buffersize.</span>
<span class="sd">    Note that for buffersize = 1 no shuffling occurs.</span>

<span class="sd">    In the following example rand = StableRandom(0) is used to create a fixed</span>
<span class="sd">    sequence that stable across Python version 2.x and 3.x. Usually, this is</span>
<span class="sd">    not what you want. Use the default rand=None which uses random.Random()</span>
<span class="sd">    instead.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Range, Collect</span>
<span class="sd">    &gt;&gt;&gt; from nutsflow.common import StableRandom</span>

<span class="sd">    &gt;&gt;&gt; Range(10) &gt;&gt; Shuffle(5, StableRandom(0)) &gt;&gt; Collect()</span>
<span class="sd">    [4, 2, 3, 6, 7, 0, 1, 9, 5, 8]</span>

<span class="sd">    &gt;&gt;&gt; Range(10) &gt;&gt; Shuffle(1, StableRandom(0)) &gt;&gt; Collect()</span>
<span class="sd">    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int buffersize: Number of elements stored in shuffle buffer.</span>
<span class="sd">    :param Random|None rand: Random number generator. If None,</span>
<span class="sd">           random.Random() is used.</span>
<span class="sd">    :return: Generator over shuffled elements</span>
<span class="sd">    :rtype: generator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rand</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span> <span class="k">if</span> <span class="n">rand</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rand</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itf</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">buffersize</span><span class="p">))</span>
    <span class="n">rand</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">e</span></div>


<div class="viewcode-block" id="MapCol"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.MapCol">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">MapCol</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; MapCol(columns, func)</span>

<span class="sd">    Apply given function to given columns of elements in iterable.</span>

<span class="sd">    &gt;&gt;&gt; neg = lambda x: -x</span>
<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; MapCol(0, neg) &gt;&gt; Collect()</span>
<span class="sd">    [(-1, 2), (-3, 4)]</span>

<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; MapCol(1, neg) &gt;&gt; Collect()</span>
<span class="sd">    [(1, -2), (3, -4)]</span>

<span class="sd">    &gt;&gt;&gt; [(1, 2), (3, 4)] &gt;&gt; MapCol((0, 1), neg) &gt;&gt; Collect()</span>
<span class="sd">    [(-1, -2), (-3, -4)]</span>

<span class="sd">    :param iterable of iterables iterable: Any iterable that contains iterables</span>
<span class="sd">    :param int|tuple of ints columns: Column index or tuple of indexes</span>
<span class="sd">    :param function func: Function to apply to elements</span>
<span class="sd">    :return: Iterator over lists</span>
<span class="sd">    :rtype: iterator of list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colset</span> <span class="o">=</span> <span class="n">as_set</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colset</span> <span class="k">else</span> <span class="n">e</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">es</span><span class="p">))</span></div>


<div class="viewcode-block" id="MapMulti"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.MapMulti">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">MapMulti</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; MapMulti(*funcs)</span>

<span class="sd">    Map multiple functions on iterable. For each function a separate iterable</span>
<span class="sd">    is returned. Can consume large amounts of memory when iterables are</span>
<span class="sd">    processed sequentially!</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Collect, _</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; nums, twos, greater2 = [1, 2, 3] &gt;&gt; MapMulti(_, _ * 2, _ &gt; 2)</span>
<span class="sd">    &gt;&gt;&gt; nums &gt;&gt; Collect()</span>
<span class="sd">    [1, 2, 3]</span>

<span class="sd">    &gt;&gt;&gt; twos &gt;&gt; Collect()</span>
<span class="sd">    [2, 4, 6]</span>

<span class="sd">    &gt;&gt;&gt; greater2 &gt;&gt; Collect()</span>
<span class="sd">    [False, False, True]</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param functions funcs: Functions to map</span>
<span class="sd">    :return: Iterators for each function</span>
<span class="sd">    :rtype: (iterator, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tees</span> <span class="o">=</span> <span class="n">itt</span><span class="o">.</span><span class="n">tee</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">tees</span><span class="p">)]</span></div>


<span class="c1"># Don&#39;t use @nut_processor here. Creating Pool is expensive!</span>
<span class="c1"># ParMap is of limited use since &#39;func&#39; must be pickable many objects are not :(</span>
<span class="c1"># pathos.multiprocesssing might be an alternative</span>
<div class="viewcode-block" id="MapPar"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.MapPar">[docs]</a><span class="k">class</span> <span class="nc">MapPar</span><span class="p">(</span><span class="n">Nut</span><span class="p">):</span>
<div class="viewcode-block" id="MapPar.__init__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.MapPar.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        iterable &gt;&gt; MapPar(func, chunksize=mp.cpu_count())</span>

<span class="sd">        Map function in parallel. Order of iterable is preserved.</span>
<span class="sd">        Note that ParMap is of limited use since &#39;func&#39; must be pickable</span>
<span class="sd">        and only top level functions (not class methods) are pickable. See</span>
<span class="sd">        https://docs.python.org/2/library/pickle.html</span>

<span class="sd">        &gt;&gt;&gt; from nutsflow import Collect</span>
<span class="sd">        &gt;&gt;&gt; [-1, -2, -3] &gt;&gt; MapPar(abs) &gt;&gt; Collect()</span>
<span class="sd">        [1, 2, 3]</span>

<span class="sd">        :param iterable iterable: Any iterable</span>
<span class="sd">        :param function func: Function to map</span>
<span class="sd">        :param int chunksize: Number of parallel processes to use for mapping.</span>
<span class="sd">        :return: Iterator over mapped elements</span>
<span class="sd">        :rtype: iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">chunksize</span></div>

<div class="viewcode-block" id="MapPar.__rrshift__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.MapPar.__rrshift__">[docs]</a>    <span class="k">def</span> <span class="nf">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">sliced</span> <span class="o">=</span> <span class="n">itt</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">sliced</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">r</span></div></div>


<div class="viewcode-block" id="Cache"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Cache">[docs]</a><span class="k">class</span> <span class="nc">Cache</span><span class="p">(</span><span class="n">Nut</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A very naive implementation of a disk cache. Pickles elements of iterable</span>
<span class="sd">    to file system and loads them the next time instead of recomputing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Cache.__init__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Cache.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cachepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clearcache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        iterable &gt;&gt; Cache()</span>

<span class="sd">        Cache elements of iterable to disk. Only worth it if elements of</span>
<span class="sd">        iterable are time-consuming to produce and can be loaded faster</span>
<span class="sd">        from disk.</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            with Cache() as cache:</span>
<span class="sd">                data = range(100)</span>
<span class="sd">                for i in range(10):</span>
<span class="sd">                    data &gt;&gt; expensive_op &gt;&gt; cache &gt;&gt; process(i) &gt;&gt; Consume()</span>


<span class="sd">        .. code:: python</span>

<span class="sd">            cache = Cache()</span>
<span class="sd">            for _ in range(100)</span>
<span class="sd">                data &gt;&gt; expensive_op &gt;&gt; cache &gt;&gt; Collect()</span>
<span class="sd">            cache.clear()</span>


<span class="sd">        .. code:: python</span>

<span class="sd">            with Cache(&#39;path/to/mycache&#39;) as cache:</span>
<span class="sd">                for _ in range(100)</span>
<span class="sd">                    data &gt;&gt; expensive_op &gt;&gt; cache &gt;&gt; Collect()</span>

<span class="sd">        :param iterable iterable: Any iterable</span>
<span class="sd">        :param string cachepath: Path to a folder that stores the cached</span>
<span class="sd">           objects. If the path does not exist it will be created. The path</span>
<span class="sd">           with all its contents will be deleted when the cache is deleted.</span>
<span class="sd">           For cachepath=None a temporary folder will be created. Path to</span>
<span class="sd">           this folder is available in cache.path.</span>
<span class="sd">        :param bool clearcache: Clear left-over cache if it exists.</span>
<span class="sd">        :return: Iterator over elements</span>
<span class="sd">        :rtype: iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="o">=</span> <span class="n">cachepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clearcache</span> <span class="o">=</span> <span class="n">clearcache</span>
        <span class="k">if</span> <span class="n">clearcache</span> <span class="ow">and</span> <span class="n">cachepath</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cachepath</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">cachepath</span><span class="p">)</span>  <span class="c1"># delete it.</span></div>

<div class="viewcode-block" id="Cache.clear"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Cache.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear cache&quot;&quot;&quot;</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_fpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return filepath for object to cache for the given index.</span>
<span class="sd">        :param int idx: Index of object in iterable</span>
<span class="sd">        :return: Filepath to pickle file</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;cache_</span><span class="si">{0:010d}</span><span class="s1">.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cache_fpaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sorted list of filepaths of cached objects.</span>

<span class="sd">        :return: Filepaths to pickle files.</span>
<span class="sd">        :rtype: list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">osp</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_create_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create either user-defined cache path or temporary path for cache data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span><span class="p">:</span>  <span class="c1"># user defined cache path.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span><span class="p">)</span>  <span class="c1"># create cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="k">else</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Context manager API to support &#39;with&#39; statement.</span>

<span class="sd">        :return: Cache itself.</span>
<span class="sd">        :rtype: Cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Context manager API. Clears the cache when exiting &#39;with&#39; statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return iterator over cached elements.</span>

<span class="sd">        :return: Generator over cached elements</span>
<span class="sd">        :rtype: Generator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fpath</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_fpaths</span><span class="p">():</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<div class="viewcode-block" id="Cache.__rrshift__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Cache.__rrshift__">[docs]</a>    <span class="k">def</span> <span class="nf">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return elements in iterable.</span>

<span class="sd">        :param iterable iterable: Any iterable</span>
<span class="sd">        :return: Generator over same elements as input iterable.</span>
<span class="sd">        :rtype: Generator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cachepath</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clearcache</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_cache</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fpath</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">e</span></div></div>


<div class="viewcode-block" id="Prefetch"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Prefetch">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Prefetch</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">num_prefetch</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Prefetch(num_prefetch=1)</span>

<span class="sd">    Prefetch elements from iterable.</span>
<span class="sd">    Typically used to keep the CPU busy while the GPU is crunching.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Take, Consume</span>
<span class="sd">    &gt;&gt;&gt; it = iter([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; it &gt;&gt; Prefetch(1) &gt;&gt; Take(1) &gt;&gt; Consume()</span>
<span class="sd">    &gt;&gt;&gt; next(it)   # doctest: +SKIP</span>
<span class="sd">    3</span>

<span class="sd">    :param iterable iterable: Any iterable</span>
<span class="sd">    :param int num_prefetch: Number of elements to prefetch.</span>
<span class="sd">    :return: Iterator over input elements</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">itf</span><span class="o">.</span><span class="n">PrefetchIterator</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">num_prefetch</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrintProgress"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.PrintProgress">[docs]</a><span class="k">class</span> <span class="nc">PrintProgress</span><span class="p">(</span><span class="n">Nut</span><span class="p">):</span>
<div class="viewcode-block" id="PrintProgress.__init__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.PrintProgress.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">every_sec</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        iterable &gt;&gt; PrintProgress(data, every_sec=10.0)</span>

<span class="sd">        Print progress on iterable. Requires that length of iterable is known</span>
<span class="sd">        beforehand. Data are just passed through.</span>
<span class="sd">        For long running computations and Estimated time of arrival (eta) is</span>
<span class="sd">        printed as well</span>

<span class="sd">        range(10) &gt;&gt; PrintProgress(10, 0) &gt;&gt; Consume()</span>

<span class="sd">        :param iterable iterable: Any iterable</span>
<span class="sd">        :param int data: Number of elements in iterable or realized iterable.</span>
<span class="sd">               If data is provided it must not be an iterator since it will be</span>
<span class="sd">               consumed!</span>
<span class="sd">        :param float every_sec: Progress is printed every &#39;every_sec&#39; seconds.</span>
<span class="sd">        :return: Iterator over input elements</span>
<span class="sd">        :rtype: iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">every_sec</span> <span class="o">=</span> <span class="n">every_sec</span></div>

<div class="viewcode-block" id="PrintProgress.__rrshift__"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.PrintProgress.__rrshift__">[docs]</a>    <span class="k">def</span> <span class="nf">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="n">etafmt</span> <span class="o">=</span> <span class="s1">&#39;(eta: </span><span class="si">{:d}</span><span class="s1">:</span><span class="si">{:02d}</span><span class="s1">:</span><span class="si">{:02d}</span><span class="s1">)&#39;</span>
        <span class="n">endfmt</span> <span class="o">=</span> <span class="s1">&#39;(took: </span><span class="si">{:d}</span><span class="s1">:</span><span class="si">{:02d}</span><span class="s1">:</span><span class="si">{:02d}</span><span class="s1">)&#39;</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">up_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">up_time</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">every_sec</span><span class="p">:</span>
                <span class="n">up_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
                <span class="n">per_done</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">sec_consumed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="n">sec_consumed</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">tstr</span> <span class="o">=</span> <span class="n">timestr</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">etafmt</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">progress: </span><span class="si">{}</span><span class="s1">% </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">per_done</span><span class="p">,</span> <span class="n">tstr</span><span class="p">)</span>
                <span class="n">console</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">e</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">progress: 100% </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">timestr</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">endfmt</span><span class="p">))</span>
        <span class="n">console</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Try"><a class="viewcode-back" href="../../nutsflow.html#nutsflow.processor.Try">[docs]</a><span class="nd">@nut_processor</span>
<span class="k">def</span> <span class="nf">Try</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;STDERR&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    iterable &gt;&gt; Try(nut)</span>

<span class="sd">    Exception handling for (nut) functions. If the wrapped nut or function </span>
<span class="sd">    raises an exception it is caught and handled with the provided handler.</span>
<span class="sd">    Per default the exception and the value causing it are printed.</span>
<span class="sd">    Furthermore a default value can be specified that is returned instead</span>
<span class="sd">    of the nut output if an exception occurs. Per default no output is</span>
<span class="sd">    returned but an error message printed (STDERR).</span>

<span class="sd">    NOTE: In the following examples &#39;STDOUT&#39; is used only to verify the</span>
<span class="sd">    error message within the doctest. In production code use the default</span>
<span class="sd">    value of &#39;STDERR&#39;.</span>

<span class="sd">    &gt;&gt;&gt; from nutsflow import Try, Collect, nut_function  </span>

<span class="sd">    &gt;&gt;&gt; [10, 2, 1] &gt;&gt; Try(lambda x : 10//x) &gt;&gt; Collect()</span>
<span class="sd">    [1, 5, 10]</span>
<span class="sd">    &gt;&gt;&gt; [10, 0, 1] &gt;&gt; Try(lambda x : 10//x, &#39;STDOUT&#39;) &gt;&gt; Collect()</span>
<span class="sd">    ERROR: 0 : integer division or modulo by zero</span>
<span class="sd">    [1, 10]</span>

<span class="sd">    &gt;&gt;&gt; Div = nut_function(lambda x : 10//x)</span>
<span class="sd">    &gt;&gt;&gt; [10, 2, 1] &gt;&gt; Try(Div()) &gt;&gt; Collect()</span>
<span class="sd">    [1, 5, 10]</span>
<span class="sd">    &gt;&gt;&gt; [10, 0, 1] &gt;&gt; Try(Div(), &#39;STDOUT&#39;) &gt;&gt; Collect()</span>
<span class="sd">    ERROR: 0 : integer division or modulo by zero</span>
<span class="sd">    [1, 10]</span>
<span class="sd">    &gt;&gt;&gt; [10, 0, 1] &gt;&gt; Try(Div(), -1) &gt;&gt; Collect()</span>
<span class="sd">    [1, -1, 10]</span>

<span class="sd">    &gt;&gt;&gt; handlezero = lambda x, e: &#39;FAILED: &#39;+str(x)</span>
<span class="sd">    &gt;&gt;&gt; [10, 0, 1] &gt;&gt; Try(Div(), handlezero) &gt;&gt; Collect()</span>
<span class="sd">    [1, &#39;FAILED: 0&#39;, 10]</span>

<span class="sd">    &gt;&gt;&gt; handlezero = lambda x, e: e</span>
<span class="sd">    &gt;&gt;&gt; [10, 0, 1] &gt;&gt; Try(Div(), handlezero) &gt;&gt; Collect()</span>
<span class="sd">    [1, ZeroDivisionError(&#39;integer division or modulo by zero&#39;,), 10]</span>

<span class="sd">    :param iterable iterable: Iterable the nut operates on.</span>
<span class="sd">    :param function|NutFunction func: (Nut) function that is wrapped </span>
<span class="sd">       for exception handling. Can be a plain Python function/method as well.</span>
<span class="sd">    :param Object default: Return value if exception occurs. </span>
<span class="sd">       If default = &#39;IGNORE&#39;, no value is returned and no error is printed.</span>
<span class="sd">       If default = &#39;STDERR&#39;, no value is returned, error is printed to stderr.</span>
<span class="sd">       If default = &#39;STDOUT&#39;, no value is returned, error is printed to stdout.</span>
<span class="sd">       If default is function that takes element x and  exception e</span>
<span class="sd">          as parameters its result is returned and no error is printed.</span>
<span class="sd">       Otherwise the default value is returned and no error is printed.</span>
<span class="sd">    :return: Iterator over input elements transformed by provided nut.</span>
<span class="sd">    :rtype: iterator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">NutFunction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">isbuiltin</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Need (nut) function in Try() :&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;IGNORE&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;STDERR&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">default</span> <span class="o">==</span> <span class="s1">&#39;STDOUT&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">default</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">default</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, IBM Research Australia.
      Last updated on Jan 25, 2018.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.26',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>